#!/usr/bin/python
# -*- coding: UTF-8 -*-

import os
from subprocess import Popen, PIPE
import json
import sys
import atexit   # supposedly for ctrl-d or something
from time import time, sleep
import re

# get the SetupParser for the .setup file
import Utils.SetupParser
SetupParser = Utils.SetupParser.SetupParser

# escape sequence to indicate command line arguments in the following line
ESC_ARGS = "#ARGS"
# escape sequence to indicate that a file has one test case per line
ESC_LINES = "#LINES"

# Methods for keeping track of time 
# (http://stackoverflow.com/questions/1557571/how-to-get-time-of-a-python-program-execution/1557906#1557906)
start = time()
def start_timer():
	# atexit.register(end_timer)
	start = time()

def end_timer():
	end = time()
	elapsed = end-start
	return elapsed

def secondsToStr(t):
    return "%d:%02d:%02d.%03d" % \
        reduce(lambda ll,b : divmod(ll[0],b) + ll[1:],
            [(t*1000,),1000,60,60])

# All debug prints can be easily commented out
def d_print(string):
	print string

# helper to parse the json into 
def ascii_encode_dict(data):
    ascii_encode = lambda x: x.encode('ascii') if isinstance(x, unicode) else x 
    return dict(map(ascii_encode, pair) for pair in data.items())

# path of this python script
my_path = os.path.dirname(sys.argv[0])   
my_path = os.path.abspath(my_path)


SETUP_DEFAULTS = {
	"testfile_base_path": my_path,
	"folder": "tests",
	"leaderboard": False
}

# parse the setup file
setup_parser = SetupParser(my_path + "/.ptest_setup", SETUP_DEFAULTS)
settings = setup_parser.settings

# gets the users name
who = os.popen('whoami').read().rstrip()


start_timer()

print "====== Public Tests ======="

public_test_file = "/c/cs323/Hwk{}/test.{}".format(settings["number"], settings["name"])
public_test = Popen(public_test_file, stdin=PIPE, stdout=PIPE, stderr=PIPE)
public_test_out, public_test_err = public_test.communicate("")

seconds = end_timer()
seconds = secondsToStr(seconds)

# split into lines
public_test_out = public_test_out.split('\n')
# search for "Error:"
failed = len(filter(lambda x: "Error:" in x, public_test_out))

if not failed and settings["leaderboard"]:
	print "success! took {} seconds".format(seconds)


#print "==== Single Line Tests ===="

print "======== Test Files ======="
num_passed = 0
num_total = 0

test_files = os.listdir(settings["folder_path"])
for test_file in test_files:
	num_total += 1

	contents = open(settings["folder_path"] + test_file).read()

	# check to see if the file is line-by-line
	if contents[0][:len(ESC_LINES)] == ESC_LINES:
		print "found line-by-line test cases"
		continue

	# otherwise, we check if there are command line arguments


	my_p = Popen(settings["name"], stdin=PIPE, stdout=PIPE, stderr=PIPE)
	my_out, my_err = my_p.communicate(contents)

	his_p = Popen(settings["his_program"], stdin=PIPE, stdout=PIPE, stderr=PIPE)
	his_out, his_err = his_p.communicate(contents)

	# compare the outputs
	if my_out != his_out:
		print "× | test {}".format(test_file)
		print "  your output: {}".format(my_out)
		print "  stans output: {}".format(his_out)
	elif len(my_err.split('\n')) != len(his_err.split('\n')):
		print "ERROR: you printed {} lines to standard error, but stan had {}".format(len(my_err.split('\n')),len(his_err.split('\n')))
	else:
		num_passed += 1
		print "✓ | test {}".format(test_file)



print "====== Final Results ======"
print "  passed : {}".format(num_passed)
print "  failed : {}".format(num_total - num_passed)
