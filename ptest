#!/usr/bin/python
# -*- coding: UTF-8 -*-

import os
from subprocess import Popen, PIPE
import json
import sys
import atexit   # supposedly for ctrl-d or something
from time import time, sleep
import requests

from Utils.SetupParser import SetupParser
from Utils.TestParser import TestParser

# escape sequence to indicate command line arguments in the following line
ESC_ARGS = "#ARGS"
# escape sequence to indicate that a file has one test case per line
ESC_LINES = "#LINES"

# url for the api
API_URL = "https://test-script.herokuapp.com/api/leaderboard/0/entries"

# Methods for keeping track of time 
# (http://stackoverflow.com/questions/1557571/how-to-get-time-of-a-python-program-execution/1557906#1557906)
start = time()
def start_timer():
	# atexit.register(end_timer)
	start = time()

def end_timer():
	end = time()
	elapsed = end-start
	return elapsed

def secondsToStr(t):
    return "%d:%02d:%02d.%03d" % \
        reduce(lambda ll,b : divmod(ll[0],b) + ll[1:],
            [(t*1000,),1000,60,60])

# All debug prints can be easily commented out
def d_print(string):
	print string

# helper to parse the json into 
def ascii_encode_dict(data):
    ascii_encode = lambda x: x.encode('ascii') if isinstance(x, unicode) else x 
    return dict(map(ascii_encode, pair) for pair in data.items())

# path of this python script
my_path = os.path.dirname(sys.argv[0])   
my_path = os.path.abspath(my_path)

# gets the users name
net_id = os.popen('whoami').read().rstrip()

SETUP_DEFAULTS = {
	"testfile_base_path": my_path,
	"folder": "tests",
	"leaderboard": False,
	"username": net_id
}

# parse the setup file
setup_parser = SetupParser(my_path + "/.ptest_setup", SETUP_DEFAULTS)
settings = setup_parser.settings

print "\n\nHey there, {}".format(settings["username"])

start_timer()

print "====== Public Tests ======="

public_test_file = "/c/cs323/Hwk{}/test.{}".format(settings["number"], settings["name"])
public_test = Popen(public_test_file, stdin=PIPE, stdout=PIPE, stderr=PIPE)
public_test_out, public_test_err = public_test.communicate("")

seconds = end_timer()

# split into lines
public_test_out = public_test_out.split('\n')
# search for "Error:"
failed = len(filter(lambda x: "Error:" in x, public_test_out))

print "\n\t".join(public_test_out)

if not failed:
	print "success! took {} seconds".format(seconds)
	if settings["leaderboard"]:
		print "posting time to leaderboard under name {}".format(settings["username"])
		post_url = API_URL
		data = {
			"net_id": net_id,
			"name": settings["username"],
			"time": time
		}
		response = requests.post(API_URL, data=data)
		if response.status_code != 200:
			print "looks like the API done goofed"

#print "==== Single Line Tests ===="

print "\n\n======== Test Files ======="
num_passed = 0
num_total = 0

# instantiate a file parser
test_parser = TestParser()
# and get the names of all the files in our folder
test_files = os.listdir(settings["folder_path"])

for test_file in test_files:

	contents = open(settings["folder_path"] + test_file).read()

	# sink the contents into the parser
	test_parser.sink(contents)

	# and run all the tests that it spits out
	while test_parser.has_test():
		cmd_args, std_in = test_parser.poll()

		my_command = [settings["name"]] + cmd_args
		his_command = [settings["his_program"]] + cmd_args
		try:
			my_p = Popen(my_command, stdin=PIPE, stdout=PIPE, stderr=PIPE)
			my_out, my_err = my_p.communicate(std_in)
		except OSError as e:
			print "Could not run command {} ({})!".format(my_command, e)
			print "Make sure you're in the same directory as the program you want to test."
			continue

		his_p = Popen(his_command, stdin=PIPE, stdout=PIPE, stderr=PIPE)
		his_out, his_err = his_p.communicate(std_in)

		# compare the outputs
		if my_out != his_out:
			print "× | test {}".format(test_file)
			print "  your output: \n{}".format("\t\n".join(my_out.split("\n")))
			print "  stans output: {}".format("\t\n".join(his_out.split("\n")))
		elif len(my_err.split('\n')) != len(his_err.split('\n')):
			print "ERROR: you printed {} lines to standard error, but stan had {}".format(len(my_err.split('\n')),len(his_err.split('\n')))
		else:
			num_passed += 1
			print "✓ | test {}".format(test_file)
		num_total += 1



print "====== Final Results ======"
print "  passed : {}".format(num_passed)
print "  failed : {}\n\n".format(num_total - num_passed)