#!/usr/bin/python
# -*- coding: UTF-8 -*-

import os
from subprocess import Popen, PIPE
import json
import sys
import atexit   # supposedly for ctrl-d or something
from time import time, sleep
import re
import Utils.SetupParser
import Utils.TestParser
SetupParser = Utils.SetupParser.SetupParser
TestParser = Utils.TestParser.TestParser

# escape sequence to indicate command line arguments in the following line
ESC_ARGS = "#ARGS"
# escape sequence to indicate that a file has one test case per line
ESC_LINES = "#LINES"

# Methods for keeping track of time 
# (http://stackoverflow.com/questions/1557571/how-to-get-time-of-a-python-program-execution/1557906#1557906)
start = time()
def start_timer():
	# atexit.register(end_timer)
	start = time()

def end_timer():
	end = time()
	elapsed = end-start
	return elapsed

def secondsToStr(t):
    return "%d:%02d:%02d.%03d" % \
        reduce(lambda ll,b : divmod(ll[0],b) + ll[1:],
            [(t*1000,),1000,60,60])

# All debug prints can be easily commented out
def d_print(string):
	print string

# helper to parse the json into 
def ascii_encode_dict(data):
    ascii_encode = lambda x: x.encode('ascii') if isinstance(x, unicode) else x 
    return dict(map(ascii_encode, pair) for pair in data.items())

# path of this python script
my_path = os.path.dirname(sys.argv[0])   
my_path = os.path.abspath(my_path)


SETUP_DEFAULTS = {
	"testfile_base_path": my_path,
	"folder": "tests",
	"leaderboard": False
}

# parse the setup file
setup_parser = SetupParser(my_path + "/.ptest_setup", SETUP_DEFAULTS)
settings = setup_parser.settings

# gets the users name
who = os.popen('whoami').read().rstrip()


start_timer()

print "====== Public Tests ======="

public_test_file = "/c/cs323/Hwk{}/test.{}".format(settings["number"], settings["name"])
public_test = Popen(public_test_file, stdin=PIPE, stdout=PIPE, stderr=PIPE)
public_test_out, public_test_err = public_test.communicate("")

seconds = end_timer()
seconds = secondsToStr(seconds)

# split into lines
public_test_out = public_test_out.split('\n')
# search for "Error:"
failed = len(filter(lambda x: "Error:" in x, public_test_out))

print "\n\t".join(public_test_out)

if not failed and settings["leaderboard"]:
	print "success! took {} seconds".format(seconds)


#print "==== Single Line Tests ===="

print "======== Test Files ======="
num_passed = 0
num_total = 0

# instantiate a file parser
test_parser = TestParser()
# and get the names of all the files in our folder
test_files = os.listdir(settings["folder_path"])

for test_file in test_files:

	contents = open(settings["folder_path"] + test_file).read()

	# sink the contents into the parser
	test_parser.sink(contents)

	# and run all the tests that it spits out
	while test_parser.has_test():
		num_total += 1
		cmd_args, std_in = test_parser.poll()
		
		my_command = " ".join([settings["name"], cmd_args]).strip()
		his_command = " ".join([settings["his_program"], cmd_args]).strip()

		my_p = Popen(my_command, stdin=PIPE, stdout=PIPE, stderr=PIPE)
		my_out, my_err = my_p.communicate(std_in)

		his_p = Popen(his_command, stdin=PIPE, stdout=PIPE, stderr=PIPE)
		his_out, his_err = his_p.communicate(std_in)

		# compare the outputs
		if my_out != his_out:
			print "× | test {}".format(test_file)
			print "  your output: {}".format(my_out)
			print "  stans output: {}".format(his_out)
		elif len(my_err.split('\n')) != len(his_err.split('\n')):
			print "ERROR: you printed {} lines to standard error, but stan had {}".format(len(my_err.split('\n')),len(his_err.split('\n')))
		else:
			num_passed += 1
			print "✓ | test {}".format(test_file)



print "====== Final Results ======"
print "  passed : {}".format(num_passed)
print "  failed : {}\n\n".format(num_total - num_passed)

